     1                                  ;*******************************************************************************************************************
     2                                  ;Program name: "Electricity". This program computes missing electrical information from a circuit consisting of *
     3                                  ;three sub-circuits running on direct current (DC). Copyright (C) 2025 Michelle Pham                                
     4                                  ;                                                                                                                   
     5                                  ;This file is part of the software program "Electricity".                                                       
     6                                  ;Electricity is free software: you can redistribute it and/or modify it under the terms of the GNU General    
     7                                  ;Public License version 3 as published by the Free Software Foundation.                                                  
     8                                  ;Electricity is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the      
     9                                  ;implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
    10                                  ;more details. A copy of the GNU General Public License v3 is available here:  <https://www.gnu.org/licenses/>.               
    11                                  ;*******************************************************************************************************************
    12                                  
    13                                  ;====================================================================================================================
    14                                  ;
    15                                  ;Author Information
    16                                  ;  Name: Michelle Pham
    17                                  ;  Email: mp28jam@csu.fullerton.edu
    18                                  ;  CWID: 867434789
    19                                  ;
    20                                  ;Program Information
    21                                  ;  Name: Electricity
    22                                  ;  Programming Language: x86-64 (Pure Assembly)
    23                                  ;  Effective Date: April 11, 2025
    24                                  ;  Latest Update: April 11, 2025
    25                                  ;  Date open source license added: April 11, 2025
    26                                  ;  Files: atof.asm, edison.asm, faraday.asm, get_res.inc, int_to_str.asm, isfloat.asm, r.sh, tesla.asm
    27                                  ;  Status: Completed
    28                                  ;  References Consulted: Ed Jorgensen, "x86-64 Assembly Language Programming with Ubuntu"
    29                                  ;  Future Upgrades: Add support for alternating current (AC) and multi-loop circuits. Improve floating-point handling 
    30                                  ;  and input validation.
    31                                  ;
    32                                  ;Purpose
    33                                  ;  This program receives partial information about a DC electric circuit composed of three sub-circuits. Based on the 
    34                                  ;  input provided by the user, it calculates missing values such as voltage, current, or resistance using Ohm’s Law 
    35                                  ;  and basic circuit rules. This project was designed not only to apply problem-solving to electrical engineering 
    36                                  ;  concepts, but also to provide the programmer with experience in developing a **pure assembly** program.
    37                                  ;
    38                                  ;Pure Assembly Philosophy
    39                                  ;  The program is intentionally built using **pure assembly language**, meaning it uses only the native x86-64 assembly
    40                                  ;  without relying on supporting languages like C or C++. This contrasts with hybrid assembly programs that interface
    41                                  ;  with high-level languages. The objective is to give the programmer a deeper understanding of low-level operations 
    42                                  ;  and direct hardware interaction by avoiding abstraction layers.
    43                                  ;
    44                                  ;Development Information
    45                                  ;  OS: Ubuntu 22.04.4 LTS
    46                                  ;  Text Editor: Github Codespaces
    47                                  ;  Tools: NASM assembler, LD linker
    48                                  ;
    49                                  ;Current File Information
    50                                  ;  Name: edison.asm
    51                                  ;  Language: x86-64 Assembly (Intel syntax)
    52                                  ;  Max page width: 130 columns
    53                                  ;  Assemble: nasm -f elf64 -l edison.lis -o edison.o edison.asm
    54                                  ;
    55                                  ;================================================================================================================================
    56                                  
    57                                  STDIN equ 0       ; Standard input
    58                                  STDOUT equ 1       ; Standard output
    59                                  SYS_read equ 0     ; syscall number for read
    60                                  SYS_write equ 1    ; syscall number for write
    61                                  
    62                                  string_size equ 48
    63                                  
    64                                  %include "get_res.inc"
     1                              <1> ;*******************************************************************************************************************
     2                              <1> ;Program name: "Electricity". This program computes missing electrical information from a circuit consisting of *
     3                              <1> ;three sub-circuits running on direct current (DC). Copyright (C) 2025 Michelle Pham                                
     4                              <1> ;                                                                                                                   
     5                              <1> ;This file is part of the software program "Electricity".                                                       
     6                              <1> ;Electricity is free software: you can redistribute it and/or modify it under the terms of the GNU General    
     7                              <1> ;Public License version 3 as published by the Free Software Foundation.                                                  
     8                              <1> ;Electricity is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the      
     9                              <1> ;implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
    10                              <1> ;more details. A copy of the GNU General Public License v3 is available here:  <https://www.gnu.org/licenses/>.               
    11                              <1> ;*******************************************************************************************************************
    12                              <1> 
    13                              <1> ;====================================================================================================================
    14                              <1> ;
    15                              <1> ;Author Information
    16                              <1> ;  Name: Michelle Pham
    17                              <1> ;  Email: mp28jam@csu.fullerton.edu
    18                              <1> ;  CWID: 867434789
    19                              <1> ;
    20                              <1> ;Program Information
    21                              <1> ;  Name: Electricity
    22                              <1> ;  Programming Language: x86-64 (Pure Assembly)
    23                              <1> ;  Effective Date: April 11, 2025
    24                              <1> ;  Latest Update: April 11, 2025
    25                              <1> ;  Date open source license added: April 11, 2025
    26                              <1> ;  Files: atof.asm, edison.asm, faraday.asm, get_res.inc, int_to_str.asm, isfloat.asm, r.sh, tesla.asm
    27                              <1> ;  Status: Completed
    28                              <1> ;  References Consulted: Ed Jorgensen, "x86-64 Assembly Language Programming with Ubuntu"
    29                              <1> ;  Future Upgrades: Add support for alternating current (AC) and multi-loop circuits. Improve floating-point handling 
    30                              <1> ;  and input validation.
    31                              <1> ;
    32                              <1> ;Purpose
    33                              <1> ;  This program receives partial information about a DC electric circuit composed of three sub-circuits. Based on the 
    34                              <1> ;  input provided by the user, it calculates missing values such as voltage, current, or resistance using Ohm’s Law 
    35                              <1> ;  and basic circuit rules. This project was designed not only to apply problem-solving to electrical engineering 
    36                              <1> ;  concepts, but also to provide the programmer with experience in developing a **pure assembly** program.
    37                              <1> ;
    38                              <1> ;Pure Assembly Philosophy
    39                              <1> ;  The program is intentionally built using **pure assembly language**, meaning it uses only the native x86-64 assembly
    40                              <1> ;  without relying on supporting languages like C or C++. This contrasts with hybrid assembly programs that interface
    41                              <1> ;  with high-level languages. The objective is to give the programmer a deeper understanding of low-level operations 
    42                              <1> ;  and direct hardware interaction by avoiding abstraction layers.
    43                              <1> ;
    44                              <1> ;Development Information
    45                              <1> ;  OS: Ubuntu 22.04.4 LTS
    46                              <1> ;  Text Editor: Github Codespaces
    47                              <1> ;  Tools: NASM assembler, LD linker
    48                              <1> ;
    49                              <1> ;Current File Information
    50                              <1> ;  Name: get_res.inc
    51                              <1> ;  Language: x86-64 Assembly (Intel syntax)
    52                              <1> ;  Max page width: 130 columns
    53                              <1> ;================================================================================================================================
    54                              <1> 
    55                              <1> ;Back-up GPRs
    56                              <1> %macro    backupGPRs 0
    57                              <1>   push    rbp
    58                              <1>   mov    rbp, rsp
    59                              <1>   push    rbx
    60                              <1>   push    rcx
    61                              <1>   push    rdx
    62                              <1>   push    rsi
    63                              <1>   push    rdi
    64                              <1>   push    r8
    65                              <1>   push    r9
    66                              <1>   push    r10
    67                              <1>   push    r11
    68                              <1>   push    r12
    69                              <1>   push    r13
    70                              <1>   push    r14
    71                              <1>   push    r15
    72                              <1>   pushf
    73                              <1> %endmacro
    74                              <1> 
    75                              <1> ;Restore GPRs
    76                              <1> %macro    restoreGPRs 0
    77                              <1>   popf
    78                              <1>   pop    r15
    79                              <1>   pop    r14
    80                              <1>   pop    r13
    81                              <1>   pop    r12
    82                              <1>   pop    r11
    83                              <1>   pop    r10
    84                              <1>   pop    r9
    85                              <1>   pop    r8
    86                              <1>   pop    rsi
    87                              <1>   pop    rdi
    88                              <1>   pop    rdx
    89                              <1>   pop    rcx
    90                              <1>   pop    rbx
    91                              <1>   pop    rbp
    92                              <1> %endmacro
    93                              <1> 
    94                              <1> %macro    backupNGPRs 1
    95                              <1>   mov    rax, 7
    96                              <1>   mov    rdx, 0
    97                              <1>   xsave    [%1]
    98                              <1> %endmacro
    99                              <1> 
   100                              <1> %macro    restoreNGPRs 1
   101                              <1>   mov    rax, 7
   102                              <1>   mov    rdx, 0
   103                              <1>   xrstor    [%1]
   104                              <1> %endmacro
   105                              <1> 
   106                              <1> 
   107                              <1> %macro GET_INPUT 3
   108                              <1>     ; %1 = destination array (e.g., arr)
   109                              <1>     ; %2 = number of elements (e.g., 3)
   110                              <1>     ; %3 = string buffer size (e.g., 32)
   111                              <1> 
   112                              <1>     xor    r15, r15             ; r15 = index
   113                              <1>     mov    r13, %1              ; r13 = base address of array
   114                              <1>     mov    r14, %2              ; r14 = number of elements
   115                              <1> 
   116                              <1> .loop_start:
   117                              <1>     cmp    r15, r14
   118                              <1>     jge    .loop_end
   119                              <1> 
   120                              <1> .loop_input:
   121                              <1>     xor    rax, rax             ; clear rax
   122                              <1>     push   qword 0              ; align stack (16-byte)
   123                              <1>     push   qword 0
   124                              <1> 
   125                              <1>     mov    rax, 0               ; syscall: SYS_read
   126                              <1>     mov    rdi, 0               ; STDIN
   127                              <1>     mov    rsi, rsp             ; buffer (top of stack)
   128                              <1>     mov    rdx, 32              ; buffer size (e.g., 32)
   129                              <1>     syscall
   130                              <1> 
   131                              <1>     cmp    eax, -1
   132                              <1>     je     .ctrl_d
   133                              <1> 
   134                              <1> 
   135                              <1>     mov     rcx, 0
   136                              <1> .loop_trim:
   137                              <1>     mov     al, byte [rsp + rcx]
   138                              <1>     cmp     al, 0
   139                              <1>     je      .done_trim
   140                              <1>     cmp     al, 10             ; newline?
   141                              <1>     jne     .not_newline
   142                              <1>     mov     byte [rsp + rcx], 0
   143                              <1>     jmp     .done_trim
   144                              <1> .not_newline:
   145                              <1>     inc     rcx
   146                              <1>     jmp     .loop_trim
   147                              <1> .done_trim:
   148                              <1> 
   149                              <1>     xor    rax, rax
   150                              <1>     mov    rdi, rsp
   151                              <1>     call   isfloat
   152                              <1>     cmp    rax, 0
   153                              <1>     je     .invalid_input
   154                              <1> 
   155                              <1>     ; Convert input string to float
   156                              <1>     xor    rax, rax
   157                              <1>     mov    rdi, rsp
   158                              <1>     call   atof
   159                              <1>     movsd  xmm15, xmm0
   160                              <1> 
   161                              <1>     ; Store into array
   162                              <1>     movsd [r13 + r15*8], xmm15
   163                              <1> 
   164                              <1>     inc    r15
   165                              <1> 
   166                              <1>     pop    rax
   167                              <1>     pop    rax
   168                              <1> 
   169                              <1>     jmp    .loop_start
   170                              <1> 
   171                              <1> .invalid_input:
   172                              <1>     pop    rax
   173                              <1>     pop    rax
   174                              <1> 
   175                              <1>     xor    rax, rax
   176                              <1>     mov    rax, 1               ; syscall: SYS_write
   177                              <1>     mov    rdi, 1               ; STDOUT
   178                              <1>     mov    rsi, prompt_input    ; prompt message address
   179                              <1>     mov    rdx, 27              ; length of prompt message
   180                              <1>     syscall
   181                              <1> 
   182                              <1>     jmp    .loop_input          ; retry input for the same index
   183                              <1> 
   184                              <1> .ctrl_d:
   185                              <1>     pop    rax
   186                              <1>     pop    rax
   187                              <1> 
   188                              <1> .loop_end:
   189                              <1>     mov    rax, r15   
   190                              <1> %endmacro
   191                              <1> 
   192                              <1> %macro FTOA_PRINT 0
   193                              <1>     ; Save original float value
   194                              <1>     movsd xmm5, xmm0
   195                              <1> 
   196                              <1>     ; Extract integer part from float
   197                              <1>     cvttsd2si rax, xmm0
   198                              <1>     mov r10, rax
   199                              <1> 
   200                              <1>     ; Convert integer part to string and print
   201                              <1>     call int_to_str
   202                              <1>     mov rsi, rax
   203                              <1>     mov rax, 1
   204                              <1>     mov rdi, 1
   205                              <1>     mov rdx, 10
   206                              <1>     syscall
   207                              <1> 
   208                              <1>     ; Multiply to shift decimal portion
   209                              <1>     movsd xmm1, [precision]
   210                              <1>     movsd xmm2, xmm0
   211                              <1>     mulsd xmm2, xmm1
   212                              <1>     cvttsd2si r9, xmm2
   213                              <1> 
   214                              <1>     ; Calculate scaled integer part for subtraction
   215                              <1>     mov r11, [precision_int]
   216                              <1>     imul r10, r11
   217                              <1> 
   218                              <1>     ; Extract decimal digits
   219                              <1>     mov r8, r9
   220                              <1>     sub r8, r10
   221                              <1>     mov rax, r8
   222                              <1>     call int_to_str
   223                              <1>     mov r12, rax
   224                              <1> 
   225                              <1>     ; Print the decimal point
   226                              <1>     mov rax, 1
   227                              <1>     mov rdi, 1
   228                              <1>     mov rsi, decimal
   229                              <1>     mov rdx, 1
   230                              <1>     syscall
   231                              <1> 
   232                              <1>     ; Print right-hand side of the decimal
   233                              <1>     mov rax, 1
   234                              <1>     mov rdi, 1
   235                              <1>     mov rsi, r12
   236                              <1>     mov rdx, 10
   237                              <1>     syscall
   238                              <1> %endmacro
   239                              <1> 
   240                              <1> %macro remove_newline 1
   241                              <1>     ; %1 = buffer address (e.g., user_name)
   242                              <1>     xor rcx, rcx
   243                              <1> .strip_loop_%1:
   244                              <1>     mov al, [%1 + rcx]
   245                              <1>     cmp al, 0
   246                              <1>     je .done_strip_%1
   247                              <1>     cmp al, 10             ; newline character?
   248                              <1>     jne .not_newline_%1
   249                              <1>     mov byte [%1 + rcx], 0 ; replace newline with null terminator
   250                              <1>     jmp .done_strip_%1
   251                              <1> .not_newline_%1:
   252                              <1>     inc rcx
   253                              <1>     jmp .strip_loop_%1
   254                              <1> .done_strip_%1:
   255                              <1> %endmacro
   256                              <1> 
   257                              <1> 
    65                                  extern isfloat
    66                                  extern atof
    67                                  extern tesla
    68                                  extern int_to_str
    69                                  
    70                                  
    71                                  section .data
    72 00000000 506C6561736520656E-     name_prompt db "Please enter your full name: ", 0
    72 00000009 74657220796F757220-
    72 00000012 66756C6C206E616D65-
    72 0000001B 3A2000             
    73 0000001E 506C6561736520656E-     career_prompt db "Please enter the career path you are following: ", 0
    73 00000027 746572207468652063-
    73 00000030 617265657220706174-
    73 00000039 6820796F7520617265-
    73 00000042 20666F6C6C6F77696E-
    73 0000004B 673A2000           
    74 0000004F 5468616E6B20796F75-     thankyou0 db "Thank you. We appreciate all ", 0
    74 00000058 2E2057652061707072-
    74 00000061 65636961746520616C-
    74 0000006A 6C2000             
    75 0000006D 732E0A0A                letter_s db "s.", 10, 10
    76 00000071 0A                      newline db "", 10
    77                                  
    78 00000072 596F75722063697263-     enter_resist      db "Your circuit has 3 sub-circuits. ", 10
    78 0000007B 756974206861732033-
    78 00000084 207375622D63697263-
    78 0000008D 756974732E200A     
    79 00000094 506C6561736520656E-              db "Please enter the resistance in ohms on each of the three sub-circuits separated by ws.", 10, 0
    79 0000009D 746572207468652072-
    79 000000A6 6573697374616E6365-
    79 000000AF 20696E206F686D7320-
    79 000000B8 6F6E2065616368206F-
    79 000000C1 662074686520746872-
    79 000000CA 6565207375622D6369-
    79 000000D3 726375697473207365-
    79 000000DC 706172617465642062-
    79 000000E5 792077732E0A00     
    80                                  
    81 000000EC 5468616E6B20796F75-     total_resist db "Thank you.", 10
    81 000000F5 2E0A               
    82 000000F7 54686520746F74616C-              db "The total resistance of the full circuit is computed to be ", 0
    82 00000100 20726573697374616E-
    82 00000109 6365206F6620746865-
    82 00000112 2066756C6C20636972-
    82 0000011B 637569742069732063-
    82 00000124 6F6D70757465642074-
    82 0000012D 6F2062652000       
    83                                           
    84 00000133 206F686D732E0A0A        emf_msg db " ohms.", 10, 10
    85 0000013B 454D4620697320636F-             db "EMF is constant on every branch of any circuit.", 10
    85 00000144 6E7374616E74206F6E-
    85 0000014D 206576657279206272-
    85 00000156 616E6368206F662061-
    85 0000015F 6E7920636972637569-
    85 00000168 742E0A             
    86 0000016B 506C6561736520656E-             db "Please enter the EMF of this circuit in volts: ", 0
    86 00000174 746572207468652045-
    86 0000017D 4D46206F6620746869-
    86 00000186 732063697263756974-
    86 0000018F 20696E20766F6C7473-
    86 00000198 3A2000             
    87                                  
    88 0000019B 5468616E6B20796F75-     compute_current db "Thank you.", 10, 10
    88 000001A4 2E0A0A             
    89 000001A7 546865206375727265-                     db "The current flowing in this circuit has been computed: "
    89 000001B0 6E7420666C6F77696E-
    89 000001B9 6720696E2074686973-
    89 000001C2 206369726375697420-
    89 000001CB 686173206265656E20-
    89 000001D4 636F6D70757465643A-
    89 000001DD 20                 
    90 000001DE 20616D70730A            last_thanks db " amps", 10
    91 000001E4 5468616E6B20796F75-                 db "Thank you ", 0
    91 000001ED 2000               
    92                                  
    93 000001EF 20666F72207573696E-     electricity db " for using this program Electricity. ", 10
    93 000001F8 672074686973207072-
    93 00000201 6F6772616D20456C65-
    93 0000020A 63747269636974792E-
    93 00000213 200A               
    94 00000215 546865206C61737420-     prompt_input    db "The last input was invalid and not entered into the array. Try again:", 10, 0
    94 0000021E 696E70757420776173-
    94 00000227 20696E76616C696420-
    94 00000230 616E64206E6F742065-
    94 00000239 6E746572656420696E-
    94 00000242 746F20746865206172-
    94 0000024B 7261792E2054727920-
    94 00000254 616761696E3A0A00   
    95                                  
    96 0000025C 2E00                    decimal db ".", 0
    97 0000025E 00000000D0126341        precision dq 10000000.0              ; For floating-point math
    98 00000266 8096980000000000        precision_int dq 10000000            ; Integer version for integer math
    99                                  
   100                                  section .bss
   101 00000000 <res 00000030>          user_name   resb string_size 
   102 00000030 <res 00000030>          career_path resb string_size
   103 00000060 <res 00000018>          arr resq 3
   104 00000078 <res 00000008>          emf resq 1
   105                                  
   106                                  section .text
   107                                  global edison
   108                                  edison:
   109                                  
   110                                      backupGPRs
   110 00000000 55                  <1>  push rbp
   110 00000001 4889E5              <1>  mov rbp, rsp
   110 00000004 53                  <1>  push rbx
   110 00000005 51                  <1>  push rcx
   110 00000006 52                  <1>  push rdx
   110 00000007 56                  <1>  push rsi
   110 00000008 57                  <1>  push rdi
   110 00000009 4150                <1>  push r8
   110 0000000B 4151                <1>  push r9
   110 0000000D 4152                <1>  push r10
   110 0000000F 4153                <1>  push r11
   110 00000011 4154                <1>  push r12
   110 00000013 4155                <1>  push r13
   110 00000015 4156                <1>  push r14
   110 00000017 4157                <1>  push r15
   110 00000019 9C                  <1>  pushf
   111                                  
   112                                      ; Print prompt for the user's full name
   113 0000001A B801000000                  mov rax, SYS_write  
   114 0000001F BF01000000                  mov rdi, STDOUT     
   115 00000024 48BE-                       mov rsi, name_prompt        
   115 00000026 [0000000000000000] 
   116 0000002E BA1E000000                  mov rdx, 30
   117 00000033 0F05                        syscall   
   118                                  
   119                                      ; Take name input 
   120 00000035 B800000000                  mov rax, SYS_read
   121 0000003A BF00000000                  mov rdi, STDIN
   122 0000003F 48BE-                       mov rsi, user_name 
   122 00000041 [0000000000000000] 
   123 00000049 BA1C000000                  mov rdx, 28 
   124 0000004E 0F05                        syscall
   125                                  
   126                                      remove_newline user_name
   126                              <1> 
   126 00000050 4831C9              <1>  xor rcx, rcx
   126                              <1> .strip_loop_%1:
   126 00000053 8A81[00000000]      <1>  mov al, [%1 + rcx]
   126 00000059 3C00                <1>  cmp al, 0
   126 0000005B 7412                <1>  je .done_strip_%1
   126 0000005D 3C0A                <1>  cmp al, 10
   126 0000005F 7509                <1>  jne .not_newline_%1
   126 00000061 C681[00000000]00    <1>  mov byte [%1 + rcx], 0
   126 00000068 EB05                <1>  jmp .done_strip_%1
   126                              <1> .not_newline_%1:
   126 0000006A 48FFC1              <1>  inc rcx
   126 0000006D EBE4                <1>  jmp .strip_loop_%1
   126                              <1> .done_strip_%1:
   127                                  
   128                                      ; Print prompt for the career path
   129 0000006F B801000000                  mov rax, SYS_write  
   130 00000074 BF01000000                  mov rdi, STDOUT     
   131 00000079 48BE-                       mov rsi, career_prompt        
   131 0000007B [1E00000000000000] 
   132 00000083 BA30000000                  mov rdx, 48 
   133 00000088 0F05                        syscall 
   134                                  
   135                                      ; Take career path input 
   136 0000008A B800000000                  mov rax, SYS_read
   137 0000008F BF00000000                  mov rdi, STDIN
   138 00000094 48BE-                       mov rsi, career_path 
   138 00000096 [3000000000000000] 
   139 0000009E BA30000000                  mov rdx, string_size 
   140 000000A3 0F05                        syscall
   141                                  
   142                                      remove_newline career_path;
   142                              <1> 
   142 000000A5 4831C9              <1>  xor rcx, rcx
   142                              <1> .strip_loop_%1:
   142 000000A8 8A81[30000000]      <1>  mov al, [%1 + rcx]
   142 000000AE 3C00                <1>  cmp al, 0
   142 000000B0 7412                <1>  je .done_strip_%1
   142 000000B2 3C0A                <1>  cmp al, 10
   142 000000B4 7509                <1>  jne .not_newline_%1
   142 000000B6 C681[30000000]00    <1>  mov byte [%1 + rcx], 0
   142 000000BD EB05                <1>  jmp .done_strip_%1
   142                              <1> .not_newline_%1:
   142 000000BF 48FFC1              <1>  inc rcx
   142 000000C2 EBE4                <1>  jmp .strip_loop_%1
   142                              <1> .done_strip_%1:
   143                                  
   144                                      ; Print prompt the first thank you
   145 000000C4 B801000000                  mov rax, SYS_write  
   146 000000C9 BF01000000                  mov rdi, STDOUT     
   147 000000CE 48BE-                       mov rsi, thankyou0        
   147 000000D0 [4F00000000000000] 
   148 000000D8 BA1E000000                  mov rdx, 30 
   149 000000DD 0F05                        syscall 
   150                                  
   151                                      ; Print career path
   152 000000DF B801000000                  mov rax, SYS_write  
   153 000000E4 BF01000000                  mov rdi, STDOUT     
   154 000000E9 48BE-                       mov rsi, career_path        
   154 000000EB [3000000000000000] 
   155 000000F3 BA14000000                  mov rdx, 20 
   156 000000F8 0F05                        syscall 
   157                                  
   158 000000FA B801000000                  mov rax, SYS_write  
   159 000000FF BF01000000                  mov rdi, STDOUT     
   160 00000104 48BE-                       mov rsi, letter_s        
   160 00000106 [6D00000000000000] 
   161 0000010E BA02000000                  mov rdx, 2 
   162 00000113 0F05                        syscall 
   163                                  
   164                                      ; Print newline
   165 00000115 B801000000                  mov rax, SYS_write  
   166 0000011A BF01000000                  mov rdi, STDOUT     
   167 0000011F 48BE-                       mov rsi, newline        
   167 00000121 [7100000000000000] 
   168 00000129 BA01000000                  mov rdx, 1 
   169 0000012E 0F05                        syscall 
   170                                  
   171                                      ; Print newline
   172 00000130 B801000000                  mov rax, SYS_write  
   173 00000135 BF01000000                  mov rdi, STDOUT     
   174 0000013A 48BE-                       mov rsi, newline        
   174 0000013C [7100000000000000] 
   175 00000144 BA01000000                  mov rdx, 1 
   176 00000149 0F05                        syscall 
   177                                  
   178                                      ; Print prompt for 3 resistance inputs
   179 0000014B B801000000                  mov rax, SYS_write  
   180 00000150 BF01000000                  mov rdi, STDOUT     
   181 00000155 48BE-                       mov rsi, enter_resist        
   181 00000157 [7200000000000000] 
   182 0000015F BA79000000                  mov rdx, 121 
   183 00000164 0F05                        syscall 
   184                                  
   185                                      ; Take input array of 3 resistances
   186 00000166 B800000000                  mov rax, 0 
   187 0000016B 48BF-                       mov rdi, arr       ; array
   187 0000016D [6000000000000000] 
   188 00000175 BE03000000                  mov rsi, 3         ; count
   189 0000017A BA20000000                  mov rdx, 32        ; string buffer size
   190                                      GET_INPUT rdi, rsi, rdx
   190                              <1> 
   190                              <1> 
   190                              <1> 
   190                              <1> 
   190 0000017F 4D31FF              <1>  xor r15, r15
   190 00000182 4989FD              <1>  mov r13, %1
   190 00000185 4989F6              <1>  mov r14, %2
   190                              <1> 
   190                              <1> .loop_start:
   190 00000188 4D39F7              <1>  cmp r15, r14
   190 0000018B 0F8D91000000        <1>  jge .loop_end
   190                              <1> 
   190                              <1> .loop_input:
   190 00000191 4831C0              <1>  xor rax, rax
   190 00000194 6A00                <1>  push qword 0
   190 00000196 6A00                <1>  push qword 0
   190                              <1> 
   190 00000198 B800000000          <1>  mov rax, 0
   190 0000019D BF00000000          <1>  mov rdi, 0
   190 000001A2 4889E6              <1>  mov rsi, rsp
   190 000001A5 BA20000000          <1>  mov rdx, 32
   190 000001AA 0F05                <1>  syscall
   190                              <1> 
   190 000001AC 83F8FF              <1>  cmp eax, -1
   190 000001AF 746F                <1>  je .ctrl_d
   190                              <1> 
   190                              <1> 
   190 000001B1 B900000000          <1>  mov rcx, 0
   190                              <1> .loop_trim:
   190 000001B6 8A040C              <1>  mov al, byte [rsp + rcx]
   190 000001B9 3C00                <1>  cmp al, 0
   190 000001BB 740F                <1>  je .done_trim
   190 000001BD 3C0A                <1>  cmp al, 10
   190 000001BF 7506                <1>  jne .not_newline
   190 000001C1 C6040C00            <1>  mov byte [rsp + rcx], 0
   190 000001C5 EB05                <1>  jmp .done_trim
   190                              <1> .not_newline:
   190 000001C7 48FFC1              <1>  inc rcx
   190 000001CA EBEA                <1>  jmp .loop_trim
   190                              <1> .done_trim:
   190                              <1> 
   190 000001CC 4831C0              <1>  xor rax, rax
   190 000001CF 4889E7              <1>  mov rdi, rsp
   190 000001D2 E8(00000000)        <1>  call isfloat
   190 000001D7 4883F800            <1>  cmp rax, 0
   190 000001DB 741E                <1>  je .invalid_input
   190                              <1> 
   190                              <1> 
   190 000001DD 4831C0              <1>  xor rax, rax
   190 000001E0 4889E7              <1>  mov rdi, rsp
   190 000001E3 E8(00000000)        <1>  call atof
   190 000001E8 F2440F10F8          <1>  movsd xmm15, xmm0
   190                              <1> 
   190                              <1> 
   190 000001ED F2470F117CFD00      <1>  movsd [r13 + r15*8], xmm15
   190                              <1> 
   190 000001F4 49FFC7              <1>  inc r15
   190                              <1> 
   190 000001F7 58                  <1>  pop rax
   190 000001F8 58                  <1>  pop rax
   190                              <1> 
   190 000001F9 EB8D                <1>  jmp .loop_start
   190                              <1> 
   190                              <1> .invalid_input:
   190 000001FB 58                  <1>  pop rax
   190 000001FC 58                  <1>  pop rax
   190                              <1> 
   190 000001FD 4831C0              <1>  xor rax, rax
   190 00000200 B801000000          <1>  mov rax, 1
   190 00000205 BF01000000          <1>  mov rdi, 1
   190 0000020A 48BE-               <1>  mov rsi, prompt_input
   190 0000020C [1502000000000000]  <1>
   190 00000214 BA1B000000          <1>  mov rdx, 27
   190 00000219 0F05                <1>  syscall
   190                              <1> 
   190 0000021B E971FFFFFF          <1>  jmp .loop_input
   190                              <1> 
   190                              <1> .ctrl_d:
   190 00000220 58                  <1>  pop rax
   190 00000221 58                  <1>  pop rax
   190                              <1> 
   190                              <1> .loop_end:
   190 00000222 4C89F8              <1>  mov rax, r15
   191                                  
   192                                      ; Call the tesla function to compute the resistance
   193 00000225 B800000000                  mov rax, 0 
   194 0000022A 48BF-                       mov rdi, arr
   194 0000022C [6000000000000000] 
   195 00000234 BE03000000                  mov rsi, 3
   196 00000239 E8(00000000)                call tesla      
   197                                             
   198                                      ; Print the output message
   199 0000023E B801000000                  mov rax, SYS_write  
   200 00000243 BF01000000                  mov rdi, STDOUT     
   201 00000248 48BE-                       mov rsi, total_resist        
   201 0000024A [EC00000000000000] 
   202 00000252 BA46000000                  mov rdx, 70
   203 00000257 0F05                        syscall  
   204                                  
   205                                      ; Convert the value from float to string and print the total resistance
   206                                      FTOA_PRINT
   206                              <1> 
   206 00000259 F20F10E8            <1>  movsd xmm5, xmm0
   206                              <1> 
   206                              <1> 
   206 0000025D F2480F2CC0          <1>  cvttsd2si rax, xmm0
   206 00000262 4989C2              <1>  mov r10, rax
   206                              <1> 
   206                              <1> 
   206 00000265 E8(00000000)        <1>  call int_to_str
   206 0000026A 4889C6              <1>  mov rsi, rax
   206 0000026D B801000000          <1>  mov rax, 1
   206 00000272 BF01000000          <1>  mov rdi, 1
   206 00000277 BA0A000000          <1>  mov rdx, 10
   206 0000027C 0F05                <1>  syscall
   206                              <1> 
   206                              <1> 
   206 0000027E F20F100C25-         <1>  movsd xmm1, [precision]
   206 00000283 [5E020000]          <1>
   206 00000287 F20F10D0            <1>  movsd xmm2, xmm0
   206 0000028B F20F59D1            <1>  mulsd xmm2, xmm1
   206 0000028F F24C0F2CCA          <1>  cvttsd2si r9, xmm2
   206                              <1> 
   206                              <1> 
   206 00000294 4C8B1C25[66020000]  <1>  mov r11, [precision_int]
   206 0000029C 4D0FAFD3            <1>  imul r10, r11
   206                              <1> 
   206                              <1> 
   206 000002A0 4D89C8              <1>  mov r8, r9
   206 000002A3 4D29D0              <1>  sub r8, r10
   206 000002A6 4C89C0              <1>  mov rax, r8
   206 000002A9 E8(00000000)        <1>  call int_to_str
   206 000002AE 4989C4              <1>  mov r12, rax
   206                              <1> 
   206                              <1> 
   206 000002B1 B801000000          <1>  mov rax, 1
   206 000002B6 BF01000000          <1>  mov rdi, 1
   206 000002BB 48BE-               <1>  mov rsi, decimal
   206 000002BD [5C02000000000000]  <1>
   206 000002C5 BA01000000          <1>  mov rdx, 1
   206 000002CA 0F05                <1>  syscall
   206                              <1> 
   206                              <1> 
   206 000002CC B801000000          <1>  mov rax, 1
   206 000002D1 BF01000000          <1>  mov rdi, 1
   206 000002D6 4C89E6              <1>  mov rsi, r12
   206 000002D9 BA0A000000          <1>  mov rdx, 10
   206 000002DE 0F05                <1>  syscall
   207                                  
   208                                      ; Print prompt for user to enter the EMF
   209 000002E0 B801000000                  mov rax, SYS_write  
   210 000002E5 BF01000000                  mov rdi, STDOUT     
   211 000002EA 48BE-                       mov rsi, emf_msg        
   211 000002EC [3301000000000000] 
   212 000002F4 BA67000000                  mov rdx, 103
   213 000002F9 0F05                        syscall 
   214                                  
   215                                      ; Take input for emf 
   216                                  emf_loop: 
   217 000002FB B800000000                  mov rax, 0 
   218 00000300 48BF-                       mov rdi, emf       ; array
   218 00000302 [7800000000000000] 
   219 0000030A BE01000000                  mov rsi, 1         ; count
   220 0000030F BA20000000                  mov rdx, 32        ; string buffer size
   221                                      GET_INPUT rdi, rsi, rdx
   221                              <1> 
   221                              <1> 
   221                              <1> 
   221                              <1> 
   221 00000314 4D31FF              <1>  xor r15, r15
   221 00000317 4989FD              <1>  mov r13, %1
   221 0000031A 4989F6              <1>  mov r14, %2
   221                              <1> 
   221                              <1> .loop_start:
   221 0000031D 4D39F7              <1>  cmp r15, r14
   221 00000320 0F8D91000000        <1>  jge .loop_end
   221                              <1> 
   221                              <1> .loop_input:
   221 00000326 4831C0              <1>  xor rax, rax
   221 00000329 6A00                <1>  push qword 0
   221 0000032B 6A00                <1>  push qword 0
   221                              <1> 
   221 0000032D B800000000          <1>  mov rax, 0
   221 00000332 BF00000000          <1>  mov rdi, 0
   221 00000337 4889E6              <1>  mov rsi, rsp
   221 0000033A BA20000000          <1>  mov rdx, 32
   221 0000033F 0F05                <1>  syscall
   221                              <1> 
   221 00000341 83F8FF              <1>  cmp eax, -1
   221 00000344 746F                <1>  je .ctrl_d
   221                              <1> 
   221                              <1> 
   221 00000346 B900000000          <1>  mov rcx, 0
   221                              <1> .loop_trim:
   221 0000034B 8A040C              <1>  mov al, byte [rsp + rcx]
   221 0000034E 3C00                <1>  cmp al, 0
   221 00000350 740F                <1>  je .done_trim
   221 00000352 3C0A                <1>  cmp al, 10
   221 00000354 7506                <1>  jne .not_newline
   221 00000356 C6040C00            <1>  mov byte [rsp + rcx], 0
   221 0000035A EB05                <1>  jmp .done_trim
   221                              <1> .not_newline:
   221 0000035C 48FFC1              <1>  inc rcx
   221 0000035F EBEA                <1>  jmp .loop_trim
   221                              <1> .done_trim:
   221                              <1> 
   221 00000361 4831C0              <1>  xor rax, rax
   221 00000364 4889E7              <1>  mov rdi, rsp
   221 00000367 E8(00000000)        <1>  call isfloat
   221 0000036C 4883F800            <1>  cmp rax, 0
   221 00000370 741E                <1>  je .invalid_input
   221                              <1> 
   221                              <1> 
   221 00000372 4831C0              <1>  xor rax, rax
   221 00000375 4889E7              <1>  mov rdi, rsp
   221 00000378 E8(00000000)        <1>  call atof
   221 0000037D F2440F10F8          <1>  movsd xmm15, xmm0
   221                              <1> 
   221                              <1> 
   221 00000382 F2470F117CFD00      <1>  movsd [r13 + r15*8], xmm15
   221                              <1> 
   221 00000389 49FFC7              <1>  inc r15
   221                              <1> 
   221 0000038C 58                  <1>  pop rax
   221 0000038D 58                  <1>  pop rax
   221                              <1> 
   221 0000038E EB8D                <1>  jmp .loop_start
   221                              <1> 
   221                              <1> .invalid_input:
   221 00000390 58                  <1>  pop rax
   221 00000391 58                  <1>  pop rax
   221                              <1> 
   221 00000392 4831C0              <1>  xor rax, rax
   221 00000395 B801000000          <1>  mov rax, 1
   221 0000039A BF01000000          <1>  mov rdi, 1
   221 0000039F 48BE-               <1>  mov rsi, prompt_input
   221 000003A1 [1502000000000000]  <1>
   221 000003A9 BA1B000000          <1>  mov rdx, 27
   221 000003AE 0F05                <1>  syscall
   221                              <1> 
   221 000003B0 E971FFFFFF          <1>  jmp .loop_input
   221                              <1> 
   221                              <1> .ctrl_d:
   221 000003B5 58                  <1>  pop rax
   221 000003B6 58                  <1>  pop rax
   221                              <1> 
   221                              <1> .loop_end:
   221 000003B7 4C89F8              <1>  mov rax, r15
   222                                  
   223                                      ; Print that the current is being calculated
   224 000003BA B801000000                  mov rax, SYS_write  
   225 000003BF BF01000000                  mov rdi, STDOUT     
   226 000003C4 48BE-                       mov rsi, compute_current        
   226 000003C6 [9B01000000000000] 
   227 000003CE BA43000000                  mov rdx, 67 
   228 000003D3 0F05                        syscall 
   229                                  
   230                                      ; Compute the current
   231 000003D5 F2440F101425-               movsd xmm10, [emf] ; Load EMF value into xmm10 e/r
   231 000003DB [78000000]         
   232 000003DF F2440F5ED5                  divsd xmm10, xmm5
   233 000003E4 F2410F10C2                  movsd xmm0, xmm10
   234                                      ; Convert the value from float to string and print the current
   235                                      FTOA_PRINT
   235                              <1> 
   235 000003E9 F20F10E8            <1>  movsd xmm5, xmm0
   235                              <1> 
   235                              <1> 
   235 000003ED F2480F2CC0          <1>  cvttsd2si rax, xmm0
   235 000003F2 4989C2              <1>  mov r10, rax
   235                              <1> 
   235                              <1> 
   235 000003F5 E8(00000000)        <1>  call int_to_str
   235 000003FA 4889C6              <1>  mov rsi, rax
   235 000003FD B801000000          <1>  mov rax, 1
   235 00000402 BF01000000          <1>  mov rdi, 1
   235 00000407 BA0A000000          <1>  mov rdx, 10
   235 0000040C 0F05                <1>  syscall
   235                              <1> 
   235                              <1> 
   235 0000040E F20F100C25-         <1>  movsd xmm1, [precision]
   235 00000413 [5E020000]          <1>
   235 00000417 F20F10D0            <1>  movsd xmm2, xmm0
   235 0000041B F20F59D1            <1>  mulsd xmm2, xmm1
   235 0000041F F24C0F2CCA          <1>  cvttsd2si r9, xmm2
   235                              <1> 
   235                              <1> 
   235 00000424 4C8B1C25[66020000]  <1>  mov r11, [precision_int]
   235 0000042C 4D0FAFD3            <1>  imul r10, r11
   235                              <1> 
   235                              <1> 
   235 00000430 4D89C8              <1>  mov r8, r9
   235 00000433 4D29D0              <1>  sub r8, r10
   235 00000436 4C89C0              <1>  mov rax, r8
   235 00000439 E8(00000000)        <1>  call int_to_str
   235 0000043E 4989C4              <1>  mov r12, rax
   235                              <1> 
   235                              <1> 
   235 00000441 B801000000          <1>  mov rax, 1
   235 00000446 BF01000000          <1>  mov rdi, 1
   235 0000044B 48BE-               <1>  mov rsi, decimal
   235 0000044D [5C02000000000000]  <1>
   235 00000455 BA01000000          <1>  mov rdx, 1
   235 0000045A 0F05                <1>  syscall
   235                              <1> 
   235                              <1> 
   235 0000045C B801000000          <1>  mov rax, 1
   235 00000461 BF01000000          <1>  mov rdi, 1
   235 00000466 4C89E6              <1>  mov rsi, r12
   235 00000469 BA0A000000          <1>  mov rdx, 10
   235 0000046E 0F05                <1>  syscall
   236                                      
   237                                      ; Print the last thanks
   238 00000470 B801000000                  mov rax, SYS_write  
   239 00000475 BF01000000                  mov rdi, STDOUT     
   240 0000047A 48BE-                       mov rsi, last_thanks        
   240 0000047C [DE01000000000000] 
   241 00000484 BA11000000                  mov rdx, 17
   242 00000489 0F05                        syscall     
   243                                  
   244                                      ; Print the user's name
   245 0000048B B801000000                  mov rax, SYS_write  
   246 00000490 BF01000000                  mov rdi, STDOUT     
   247 00000495 48BE-                       mov rsi, user_name        
   247 00000497 [0000000000000000] 
   248 0000049F BA10000000                  mov rdx, 16 
   249 000004A4 0F05                        syscall 
   250                                  
   251                                      ; Print the final output
   252 000004A6 B801000000                  mov rax, SYS_write  
   253 000004AB BF01000000                  mov rdi, STDOUT     
   254 000004B0 48BE-                       mov rsi, electricity        
   254 000004B2 [EF01000000000000] 
   255 000004BA BA26000000                  mov rdx, 38
   256 000004BF 0F05                        syscall 
   257                                  
   258                                      restoreGPRs
   258 000004C1 9D                  <1>  popf
   258 000004C2 415F                <1>  pop r15
   258 000004C4 415E                <1>  pop r14
   258 000004C6 415D                <1>  pop r13
   258 000004C8 415C                <1>  pop r12
   258 000004CA 415B                <1>  pop r11
   258 000004CC 415A                <1>  pop r10
   258 000004CE 4159                <1>  pop r9
   258 000004D0 4158                <1>  pop r8
   258 000004D2 5E                  <1>  pop rsi
   258 000004D3 5F                  <1>  pop rdi
   258 000004D4 5A                  <1>  pop rdx
   258 000004D5 59                  <1>  pop rcx
   258 000004D6 5B                  <1>  pop rbx
   258 000004D7 5D                  <1>  pop rbp
   259 000004D8 C3                          ret
